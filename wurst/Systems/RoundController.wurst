package RoundController
import GroupUtils
import Entity
import HeroSelector
import Creeps
import Team
import HeroEntity
import FountainOfLife
import FountainOfMana
import GoblinMerchant
import MarketPlace
import Config
import ClosureTimers
import ClosureForGroups
import GameState


public class RoundController
    private LinkedList<Entity> entities
    private LinkedList<Entity> array[2] heroes
    private Creeps creeps

    construct()
        entities = new LinkedList<Entity>()
        creeps = new Creeps()
        heroes[0] = new LinkedList<Entity>()
        heroes[1] = new LinkedList<Entity>()
    
    function start()
        spawnBuildings(Team.RABBITS)
        spawnBuildings(Team.SHEEP)
        for p in Team.RABBITS.getPlayers()
            spawnHero(p, Team.RABBITS, randomHeroId())
        for p in Team.SHEEP.getPlayers()
            spawnHero(p, Team.SHEEP, randomHeroId())
        creeps.add(Team.SHEEP)
        creeps.add(Team.RABBITS)
        spawnHero(Player(6), Team.SHEEP, randomHeroId())
        doPeriodically(0.1) cb ->
            if gameState != GameState.PLAYING
                destroy cb
            else
                checkWinCondition()
    
    private function checkWinCondition()
        if creeps.getCreepCount(Team.RABBITS) > MAX_CREEP
            teamWin(Team.RABBITS)
        else if creeps.getCreepCount(Team.SHEEP) > MAX_CREEP
            teamWin(Team.SHEEP)
        else if heroes[Team.RABBITS castTo int].size() <= 0
            teamWin(Team.SHEEP) 
        else if heroes[Team.SHEEP castTo int].size() <= 0
            teamWin(Team.RABBITS) 
    
    private function teamWin(Team t)
        print("Won: " + (t castTo int).toString())
        gameState = GameState.INBETWEEN
    
    private function spawnHero(player p, Team t, int id) returns Entity
        let hero = new HeroEntity(p, t.rect().getCenter(), id)
        heroes[t castTo int].add(hero)
        EventListener.add(hero.actor, EVENT_PLAYER_UNIT_DEATH) ->
            heroes[t castTo int].remove(hero)
            destroy hero
        return hero 
    
    private function clearMap()
        forUnitsInRect(playableMapRect) u ->
            if u.getEntity() != null
                destroy u.getEntity()
            else
                u.remove()
        entities.clear()
        heroes[0].clear()
        heroes[1].clear()
        creeps.clear()
        
    private function spawnBuildings(Team team)
        var map = new LinkedList<int>()
        for i = 0 to 3
            map.add(i)
        map.shuffle()
        let pos = [team.rect().getLeftTop(), team.rect().getRightBot(), team.rect().getRightTop(), team.rect().getLeftBot()]
        entities.add(new FountainOfLife(DUMMY_PLAYER, pos[map.get(0)].add(BUILDING_OFFSETS[map.get(0)])))
        entities.add(new FountainOfMana(DUMMY_PLAYER, pos[map.get(1)].add(BUILDING_OFFSETS[map.get(1)])))
        entities.add(new GoblinMerchant(DUMMY_PLAYER, pos[map.get(2)].add(BUILDING_OFFSETS[map.get(2)])))
        entities.add(new MarketPlace(DUMMY_PLAYER, pos[map.get(3)].add(BUILDING_OFFSETS[map.get(3)])))
        